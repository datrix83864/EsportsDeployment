---
# Create a Proxmox cloud-init template from an Ubuntu cloud image
# This playbook runs on the Proxmox host (via SSH) and performs the steps
# similar to the helper shell script: download image, import disk, set VM, convert to template.

- name: Create Proxmox cloud-init template
  hosts: all
  gather_facts: false
  become: true

  vars:
    tmp_base: /var/tmp
    memory: 2048
    cores: 2

  tasks:
    - name: Display playbook banner
      debug:
        msg: |

          ╔════════════════════════════════════════════════════════════════╗
          ║                                                                ║
          ║  🔧  PROXMOX CLOUD-INIT TEMPLATE CREATION                     ║
          ║                                                                ║
          ╠════════════════════════════════════════════════════════════════╣
          ║  This playbook will:                                          ║
          ║  1. Download Ubuntu cloud image (~700MB)                      ║
          ║  2. Verify image integrity with checksums                     ║
          ║  3. Import image to Proxmox storage                           ║
          ║  4. Create and configure cloud-init template                  ║
          ║  5. Validate template is bootable                             ║
          ║                                                                ║
          ║  Target: {{ storage }} on {{ inventory_hostname }}
          ║  Template Name: {{ template_name }}
          ╚════════════════════════════════════════════════════════════════╝

    - name: Ensure python is present (Ansible remote requirements)
      raw: test -x "$(command -v python3)" || apt-get update && apt-get install -y python3
      changed_when: false

    - name: Fetch next available VMID
      shell: pvesh get /cluster/nextid
      register: nextid

    - name: Set VMID fact
      set_fact:
        vmid: "{{ nextid.stdout | trim }}"

    - name: Display assigned VMID
      debug:
        msg: "📋 Assigned VMID: {{ vmid }}"

    - name: Prepare temporary directory
      file:
        path: "{{ tmp_base }}/cloudimg-{{ vmid }}"
        state: directory
        mode: "0755"

    - name: Check if cloud image already exists
      stat:
        path: "{{ tmp_base }}/cloudimg-{{ vmid }}/{{ image_url | basename }}"
      register: image_file

    - name: Display download message
      debug:
        msg: |
          ╔════════════════════════════════════════════════════════════════╗
          ║  DOWNLOADING UBUNTU CLOUD IMAGE                                ║
          ╠════════════════════════════════════════════════════════════════╣
          ║  Source: {{ image_url }}
          ║  Size: ~700MB                                                  ║
          ║  Expected Time: 1-30 minutes (depending on connection)        ║
          ║  Timeout: 60 minutes (no timeout as long as progress is made) ║
          ║                                                                ║
          ║  ⏳ Please wait... Download progress will be shown below      ║
          ║  💡 Even on slow connections, this will complete eventually   ║
          ╚════════════════════════════════════════════════════════════════╝
      when: not image_file.stat.exists

    - name: Download cloud image with progress monitoring
      shell: |
        cd {{ tmp_base }}/cloudimg-{{ vmid }}

        # Download with wget showing progress bar
        # No timeout as long as data is being received (wget default behavior)
        # Will retry up to 20 times with exponential backoff
        echo "⬇️  Starting download... (this may take a while on slow connections)"
        wget --progress=bar:force:noscroll \
             --tries=20 \
             --read-timeout=3600 \
             --dns-timeout=300 \
             --connect-timeout=300 \
             --waitretry=30 \
             -c \
             -O "{{ image_url | basename }}" \
             "{{ image_url }}" 2>&1 | \
        while IFS= read -r line; do
          # Show progress with spinning indicator
          if [[ "$line" =~ [0-9]+% ]]; then
            echo "$line"
          fi
        done

        # Check if download succeeded
        if [ -f "{{ image_url | basename }}" ]; then
          FILE_SIZE=$(stat -c%s "{{ image_url | basename }}" 2>/dev/null || stat -f%z "{{ image_url | basename }}" 2>/dev/null)
          echo "✓ Download completed successfully ($(numfmt --to=iec-i --suffix=B ${FILE_SIZE} 2>/dev/null || echo ${FILE_SIZE} bytes))"
          exit 0
        else
          echo "✗ Download failed"
          exit 1
        fi
      args:
        creates: "{{ tmp_base }}/cloudimg-{{ vmid }}/{{ image_url | basename }}"
      when: not image_file.stat.exists
      register: download_result
      retries: 3 # Will retry the entire download up to 3 times if it fails
      delay: 30
      until: download_result.rc == 0

    - name: Show download result
      debug:
        msg: "✓ Cloud image downloaded successfully ({{ (image_size.stat.size / 1024 / 1024) | int }}MB)"
      when:
        - download_result is succeeded
        - not image_file.stat.exists

    - name: Download SHA256SUMS for verification
      get_url:
        url: "{{ image_url | regex_replace('/[^/]+$', '/SHA256SUMS') }}"
        dest: "{{ tmp_base }}/cloudimg-{{ vmid }}/SHA256SUMS"
        timeout: 30
      ignore_errors: true
      register: checksum_download

    - name: Verify cloud image checksum
      debug:
        msg: "🔍 Verifying image integrity with SHA256 checksum..."
      when: checksum_download is succeeded

    - name: Calculate and compare checksums
      shell: |
        cd {{ tmp_base }}/cloudimg-{{ vmid }}
        echo "📊 Comparing checksums..."

        # Try to find checksum for this specific file
        EXPECTED=$(grep "{{ image_url | basename }}" SHA256SUMS | awk '{print $1}' || echo "")

        if [ -z "${EXPECTED}" ]; then
          echo "⚠️  No checksum found in SHA256SUMS for {{ image_url | basename }}"
          echo "   This can happen when using /current/ symlink URLs"
          echo "   Skipping checksum verification (file size check will still validate)"
          exit 0
        fi

        echo "   Expected: ${EXPECTED}"
        echo "   Calculating actual checksum (this may take 30-60 seconds)..."
        ACTUAL=$(sha256sum "{{ image_url | basename }}" | awk '{print $1}')
        echo "   Actual:   ${ACTUAL}"

        if [ "${ACTUAL}" != "${EXPECTED}" ]; then
          echo "❌ CHECKSUM_MISMATCH: Image is corrupted or partially downloaded!"
          echo "   Removing corrupted file to allow retry..."
          rm -f "{{ image_url | basename }}"
          exit 1
        fi

        echo "✅ Checksum verified successfully - image is valid"
      when: checksum_download is succeeded
      register: checksum_verify
      ignore_errors: true

    - name: Show checksum verification result
      debug:
        msg: "{{ checksum_verify.stdout_lines | default(['⚠️  Checksum verification skipped']) }}"
      when: checksum_download is succeeded

    - name: Warn if checksum verification was skipped or failed
      debug:
        msg: |
          ⚠️  WARNING: Checksum verification was not completed
          Proceeding with file size validation only.
          The image will still be validated for minimum size (200MB).
      when: checksum_download is failed or (checksum_verify is defined and checksum_verify is failed)

    - name: Validate image file size (should be > 200MB)
      stat:
        path: "{{ tmp_base }}/cloudimg-{{ vmid }}/{{ image_url | basename }}"
      register: image_size

    - name: Check if image file is large enough
      fail:
        msg: "❌ Downloaded image is too small ({{ (image_size.stat.size / 1024 / 1024) | int }}MB). Expected > 200MB. Download may be corrupted."
      when: image_size.stat.size < 209715200

    - name: Creating Proxmox VM
      debug:
        msg: "🔧 Step 1/4: Creating temporary VM {{ vmid }} on Proxmox..."

    - name: Create temporary VM
      shell: |
        qm create {{ vmid }} --name temp-import-{{ vmid }} --memory {{ memory }} --cores {{ cores }} || true

    - name: Importing disk to storage
      debug:
        msg: "💾 Step 2/4: Importing cloud image to storage '{{ storage }}' (this may take 1-2 minutes)..."

    - name: Import disk into storage
      shell: |
        echo "   Importing {{ image_url | basename }}..."
        qm importdisk {{ vmid }} {{ tmp_base }}/cloudimg-{{ vmid }}/{{ image_url | basename }} {{ storage }}
        echo "   ✓ Disk imported successfully"

    - name: Configuring VM
      debug:
        msg: "⚙️  Step 3/4: Configuring VM boot settings and cloud-init..."

    - name: Attach imported disk as scsi0 and configure VM
      shell: |
        qm set {{ vmid }} --scsi0 {{ storage }}:vm-{{ vmid }}-disk-0
        qm set {{ vmid }} --boot order=scsi0
        qm set {{ vmid }} --agent 1

    - name: Converting to template
      debug:
        msg: "📦 Step 4/4: Converting VM to template..."

    - name: Convert VM to template
      shell: |
        qm template {{ vmid }}

    - name: Set template name
      shell: |
        qm set {{ vmid }} --name {{ template_name }} || true

    - name: Validating template
      debug:
        msg: "🔍 Validating template boot disk configuration..."

    - name: Validate template has boot disk configured
      shell: |
        qm config {{ vmid }} | grep -E '^(scsi0|ide0|sata0):'
      register: boot_disk_check
      failed_when: boot_disk_check.rc != 0

    - name: Display boot disk configuration
      debug:
        msg: "✅ Template validated - Boot disk: {{ boot_disk_check.stdout }}"

    - name: Cleaning up
      debug:
        msg: "🧹 Cleaning up temporary files..."

    - name: Cleanup temporary files
      file:
        path: "{{ tmp_base }}/cloudimg-{{ vmid }}"
        state: absent

    - name: Show completion message
      debug:
        msg: |

          ╔════════════════════════════════════════════════════════════════╗
          ║                                                                ║
          ║  ✅  SUCCESS! CLOUD-INIT TEMPLATE CREATED & VALIDATED         ║
          ║                                                                ║
          ╠════════════════════════════════════════════════════════════════╣
          ║  Template Name:  {{ template_name }}
          ║  VMID:           {{ vmid }}
          ║  Proxmox Host:   {{ inventory_hostname }}
          ║  Boot Disk:      {{ boot_disk_check.stdout }}
          ╚════════════════════════════════════════════════════════════════╝

          🚀 Template is ready for VM deployment!
