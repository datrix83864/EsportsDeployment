---
# Create a Proxmox cloud-init template from an Ubuntu cloud image
# This playbook runs on the Proxmox host (via SSH) and performs the steps
# similar to the helper shell script: download image, import disk, set VM, convert to template.

- name: Create Proxmox cloud-init template
  hosts: all
  gather_facts: false
  become: true

  vars:
    tmp_base: /var/tmp
    memory: 2048
    cores: 2

  tasks:
    - name: Display playbook banner
      debug:
        msg: |

          ╔════════════════════════════════════════════════════════════════╗
          ║                                                                ║
          ║  🔧  PROXMOX CLOUD-INIT TEMPLATE CREATION                     ║
          ║                                                                ║
          ╠════════════════════════════════════════════════════════════════╣
          ║  This playbook will:                                          ║
          ║  1. Download Ubuntu cloud image (~700MB)                      ║
          ║  2. Verify image integrity with checksums                     ║
          ║  3. Import image to Proxmox storage                           ║
          ║  4. Create and configure cloud-init template                  ║
          ║  5. Validate template is bootable                             ║
          ║                                                                ║
          ║  Target: {{ storage }} on {{ inventory_hostname }}
          ║  Template Name: {{ template_name }}
          ╚════════════════════════════════════════════════════════════════╝

    - name: Ensure python is present (Ansible remote requirements)
      raw: test -x "$(command -v python3)" || apt-get update && apt-get install -y python3
      changed_when: false

    - name: Fetch next available VMID
      shell: pvesh get /cluster/nextid
      register: nextid

    - name: Set VMID fact
      set_fact:
        vmid: "{{ nextid.stdout | trim }}"

    - name: Display assigned VMID
      debug:
        msg: "📋 Assigned VMID: {{ vmid }}"

    - name: Prepare temporary directory
      file:
        path: "{{ tmp_base }}/cloudimg-{{ vmid }}"
        state: directory
        mode: "0755"

    - name: Check if cloud image already exists
      stat:
        path: "{{ tmp_base }}/cloudimg-{{ vmid }}/{{ image_url | basename }}"
      register: image_file

    - name: Display download message
      debug:
        msg: |
          ╔════════════════════════════════════════════════════════════════╗
          ║  DOWNLOADING UBUNTU CLOUD IMAGE                                ║
          ╠════════════════════════════════════════════════════════════════╣
          ║  Source: {{ image_url }}
          ║  Size: ~700MB                                                  ║
          ║  Expected Time: 1-30 minutes (depending on connection)        ║
          ║  Timeout: 60 minutes (no timeout as long as progress is made) ║
          ║                                                                ║
          ║  ⏳ Please wait... Download progress will be shown below      ║
          ║  💡 Even on slow connections, this will complete eventually   ║
          ╚════════════════════════════════════════════════════════════════╝
      when: not image_file.stat.exists

    - name: Download cloud image with progress monitoring
      shell: |
        #!/bin/bash
        cd {{ tmp_base }}/cloudimg-{{ vmid }}

        # Download with wget showing progress bar
        # No timeout as long as data is being received (wget default behavior)
        # Will retry up to 20 times with exponential backoff
        echo "⬇️  Starting download... (this may take a while on slow connections)"
        wget --progress=bar:force:noscroll \
             --tries=20 \
             --read-timeout=3600 \
             --dns-timeout=300 \
             --connect-timeout=300 \
             --waitretry=30 \
             -c \
             -O "{{ image_url | basename }}" \
             "{{ image_url }}" 2>&1 | \
        while IFS= read -r line; do
          # Show progress with spinning indicator
          if [[ "$line" =~ [0-9]+% ]]; then
            echo "$line"
          fi
        done

        # Check if download succeeded
        if [ -f "{{ image_url | basename }}" ]; then
          FILE_SIZE=$(stat -c%s "{{ image_url | basename }}" 2>/dev/null || stat -f%z "{{ image_url | basename }}" 2>/dev/null)
          echo "✓ Download completed successfully ($(numfmt --to=iec-i --suffix=B ${FILE_SIZE} 2>/dev/null || echo ${FILE_SIZE} bytes))"
          exit 0
        else
          echo "✗ Download failed"
          exit 1
        fi
      args:
        creates: "{{ tmp_base }}/cloudimg-{{ vmid }}/{{ image_url | basename }}"
        executable: /bin/bash
      when: not image_file.stat.exists
      register: download_result
      retries: 3 # Will retry the entire download up to 3 times if it fails
      delay: 30
      until: download_result.rc == 0

    - name: Show download result
      debug:
        msg: "✓ Cloud image download complete"
      when:
        - download_result is succeeded
        - not image_file.stat.exists

    - name: Download SHA256SUMS for verification
      get_url:
        url: "{{ image_url | regex_replace('/[^/]+$', '/SHA256SUMS') }}"
        dest: "{{ tmp_base }}/cloudimg-{{ vmid }}/SHA256SUMS"
        timeout: 30
      ignore_errors: true
      register: checksum_download

    - name: Verify cloud image checksum
      debug:
        msg: "🔍 Verifying image integrity with SHA256 checksum..."
      when: checksum_download is succeeded

    - name: Calculate and compare checksums
      shell: |
        cd {{ tmp_base }}/cloudimg-{{ vmid }}
        echo "📊 Comparing checksums..."

        # Try to find checksum for this specific file
        EXPECTED=$(grep "{{ image_url | basename }}" SHA256SUMS | awk '{print $1}' || echo "")

        if [ -z "${EXPECTED}" ]; then
          echo "⚠️  No checksum found in SHA256SUMS for {{ image_url | basename }}"
          echo "   This can happen when using /current/ symlink URLs"
          echo "   Skipping checksum verification (file size check will still validate)"
          exit 0
        fi

        echo "   Expected: ${EXPECTED}"
        echo "   Calculating actual checksum (this may take 30-60 seconds)..."
        ACTUAL=$(sha256sum "{{ image_url | basename }}" | awk '{print $1}')
        echo "   Actual:   ${ACTUAL}"

        if [ "${ACTUAL}" != "${EXPECTED}" ]; then
          echo "❌ CHECKSUM_MISMATCH: Image is corrupted or partially downloaded!"
          echo "   Removing corrupted file to allow retry..."
          rm -f "{{ image_url | basename }}"
          exit 1
        fi

        echo "✅ Checksum verified successfully - image is valid"
      when: checksum_download is succeeded
      register: checksum_verify
      ignore_errors: true

    - name: Show checksum verification result
      debug:
        msg: "{{ checksum_verify.stdout_lines | default(['⚠️  Checksum verification skipped']) }}"
      when: checksum_download is succeeded

    - name: Warn if checksum verification was skipped or failed
      debug:
        msg: |
          ⚠️  WARNING: Checksum verification was not completed
          Proceeding with file size validation only.
          The image will still be validated for minimum size (200MB).
      when: checksum_download is failed or (checksum_verify is defined and checksum_verify is failed)

    - name: Validate image file size (should be > 200MB)
      stat:
        path: "{{ tmp_base }}/cloudimg-{{ vmid }}/{{ image_url | basename }}"
      register: image_size

    - name: Check if image file is large enough
      fail:
        msg: "❌ Downloaded image is too small ({{ (image_size.stat.size / 1024 / 1024) | int }}MB). Expected > 200MB. Download may be corrupted."
      when: image_size.stat.size < 209715200

    - name: Creating Proxmox VM
      debug:
        msg: "🔧 Step 1/4: Creating temporary VM {{ vmid }} on Proxmox..."

    - name: Create temporary VM
      shell: |
        #!/bin/bash
        set -e
        echo "Creating VM {{ vmid }}..."
        qm create {{ vmid }} --name temp-import-{{ vmid }} --memory {{ memory }} --cores {{ cores }}
        echo "✓ VM created successfully"
      args:
        executable: /bin/bash
      register: vm_create_result

    - name: Display VM creation result
      debug:
        msg: "{{ vm_create_result.stdout_lines }}"

    - name: Importing disk to storage
      debug:
        msg: "💾 Step 2/4: Importing cloud image to storage '{{ storage }}' (this may take 1-2 minutes)..."

    - name: Import disk into storage
      shell: |
        #!/bin/bash
        set -e
        cd {{ tmp_base }}/cloudimg-{{ vmid }}
        echo "   Importing {{ image_url | basename }} to storage {{ storage }}..."
        echo "   This may take 1-2 minutes depending on storage speed..."
        
        # Import the disk and capture output
        if qm importdisk {{ vmid }} "{{ image_url | basename }}" {{ storage }} 2>&1 | tee /tmp/import_{{ vmid }}.log; then
          echo "   ✓ Disk imported successfully"
          
          # Verify the disk was created
          if pvesm list {{ storage }} | grep -q "vm-{{ vmid }}-disk-0"; then
            echo "   ✓ Verified: Disk vm-{{ vmid }}-disk-0 exists in storage"
          else
            echo "   ❌ ERROR: Disk was not created in storage!"
            echo "   Available disks for VM {{ vmid }}:"
            pvesm list {{ storage }} | grep "vm-{{ vmid }}" || echo "   No disks found!"
            exit 1
          fi
        else
          echo "   ❌ ERROR: qm importdisk failed!"
          cat /tmp/import_{{ vmid }}.log
          exit 1
        fi
      args:
        executable: /bin/bash
      register: import_result

    - name: Display import result
      debug:
        msg: "{{ import_result.stdout_lines }}"

    - name: Configuring VM
      debug:
        msg: "⚙️  Step 3/4: Configuring VM boot settings and cloud-init..."

    - name: Attach imported disk as scsi0 and configure VM
      shell: |
        #!/bin/bash
        set -e
        echo "Attaching disk to VM {{ vmid }}..."
        
        # Attach the disk
        if qm set {{ vmid }} --scsi0 {{ storage }}:vm-{{ vmid }}-disk-0; then
          echo "✓ Disk attached as scsi0"
        else
          echo "❌ Failed to attach disk!"
          exit 1
        fi
        
        # Set boot order
        if qm set {{ vmid }} --boot order=scsi0; then
          echo "✓ Boot order set to scsi0"
        else
          echo "❌ Failed to set boot order!"
          exit 1
        fi
        
        # Enable QEMU agent
        if qm set {{ vmid }} --agent 1; then
          echo "✓ QEMU agent enabled"
        else
          echo "⚠  Warning: Failed to enable QEMU agent (non-critical)"
        fi
        
        # Verify the configuration
        echo ""
        echo "Verifying VM configuration..."
        if qm config {{ vmid }} | grep -E "^scsi0:" > /dev/null; then
          SCSI0_LINE=$(qm config {{ vmid }} | grep "^scsi0:")
          echo "✓ Boot disk configured: ${SCSI0_LINE}"
        else
          echo "❌ CRITICAL ERROR: No boot disk (scsi0) found in VM config!"
          echo "Full VM config:"
          qm config {{ vmid }}
          exit 1
        fi
        
        if qm config {{ vmid }} | grep -E "^boot:" > /dev/null; then
          BOOT_LINE=$(qm config {{ vmid }} | grep "^boot:")
          echo "✓ Boot order configured: ${BOOT_LINE}"
        else
          echo "⚠  Warning: No boot order in config (may use defaults)"
        fi
      args:
        executable: /bin/bash
      register: attach_result

    - name: Display attachment result
      debug:
        msg: "{{ attach_result.stdout_lines }}"

    - name: Converting to template
      debug:
        msg: "📦 Step 4/4: Converting VM to template..."

    - name: Convert VM to template
      shell: |
        qm template {{ vmid }}

    - name: Set template name
      shell: |
        qm set {{ vmid }} --name {{ template_name }} || true

    - name: Validating template
      debug:
        msg: "🔍 Validating template boot disk configuration..."

    - name: Validate template has boot disk configured
      shell: |
        qm config {{ vmid }} | grep -E '^(scsi0|ide0|sata0):'
      register: boot_disk_check
      failed_when: boot_disk_check.rc != 0

    - name: Display boot disk configuration
      debug:
        msg: "✅ Template validated - Boot disk: {{ boot_disk_check.stdout }}"

    - name: Cleaning up
      debug:
        msg: "🧹 Cleaning up temporary files..."

    - name: Cleanup temporary files
      file:
        path: "{{ tmp_base }}/cloudimg-{{ vmid }}"
        state: absent

    - name: Show completion message
      debug:
        msg: |

          ╔════════════════════════════════════════════════════════════════╗
          ║                                                                ║
          ║  ✅  SUCCESS! CLOUD-INIT TEMPLATE CREATED & VALIDATED         ║
          ║                                                                ║
          ╠════════════════════════════════════════════════════════════════╣
          ║  Template Name:  {{ template_name }}
          ║  VMID:           {{ vmid }}
          ║  Proxmox Host:   {{ inventory_hostname }}
          ║  Boot Disk:      {{ boot_disk_check.stdout }}
          ╚════════════════════════════════════════════════════════════════╝

          🚀 Template is ready for VM deployment!
