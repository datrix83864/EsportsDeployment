---
# Create a Proxmox cloud-init template from an Ubuntu cloud image
# This playbook runs on the Proxmox host (via SSH) and performs the steps
# similar to the helper shell script: download image, import disk, set VM, convert to template.

- name: Create Proxmox cloud-init template
  hosts: all
  gather_facts: false
  become: true

  vars:
    tmp_base: /var/tmp
    memory: 2048
    cores: 2

  tasks:
    - name: Display playbook banner
      debug:
        msg: |

          โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
          โ                                                                โ
          โ  ๐ง  PROXMOX CLOUD-INIT TEMPLATE CREATION                     โ
          โ                                                                โ
          โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโฃ
          โ  This playbook will:                                          โ
          โ  1. Download Ubuntu cloud image (~700MB)                      โ
          โ  2. Verify image integrity with checksums                     โ
          โ  3. Import image to Proxmox storage                           โ
          โ  4. Create and configure cloud-init template                  โ
          โ  5. Validate template is bootable                             โ
          โ                                                                โ
          โ  Target: {{ storage }} on {{ inventory_hostname }}
          โ  Template Name: {{ template_name }}
          โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ

    - name: Ensure python is present (Ansible remote requirements)
      raw: test -x "$(command -v python3)" || apt-get update && apt-get install -y python3
      changed_when: false

    - name: Fetch next available VMID
      shell: pvesh get /cluster/nextid
      register: nextid

    - name: Set VMID fact
      set_fact:
        vmid: "{{ nextid.stdout | trim }}"

    - name: Display assigned VMID
      debug:
        msg: "๐ Assigned VMID: {{ vmid }}"

    - name: Prepare temporary directory
      file:
        path: "{{ tmp_base }}/cloudimg-{{ vmid }}"
        state: directory
        mode: "0755"

    - name: Check if cloud image already exists
      stat:
        path: "{{ tmp_base }}/cloudimg-{{ vmid }}/{{ image_url | basename }}"
      register: image_file

    - name: Display download message
      debug:
        msg: |
          โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
          โ  DOWNLOADING UBUNTU CLOUD IMAGE                                โ
          โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโฃ
          โ  Source: {{ image_url }}
          โ  Size: ~700MB                                                  โ
          โ  Expected Time: 1-30 minutes (depending on connection)        โ
          โ  Timeout: 60 minutes (no timeout as long as progress is made) โ
          โ                                                                โ
          โ  โณ Please wait... Download progress will be shown below      โ
          โ  ๐ก Even on slow connections, this will complete eventually   โ
          โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
      when: not image_file.stat.exists

    - name: Download cloud image with progress monitoring
      shell: |
        #!/bin/bash
        cd {{ tmp_base }}/cloudimg-{{ vmid }}

        # Download with wget showing progress bar
        # No timeout as long as data is being received (wget default behavior)
        # Will retry up to 20 times with exponential backoff
        echo "โฌ๏ธ  Starting download... (this may take a while on slow connections)"
        wget --progress=bar:force:noscroll \
             --tries=20 \
             --read-timeout=3600 \
             --dns-timeout=300 \
             --connect-timeout=300 \
             --waitretry=30 \
             -c \
             -O "{{ image_url | basename }}" \
             "{{ image_url }}" 2>&1 | \
        while IFS= read -r line; do
          # Show progress with spinning indicator
          if [[ "$line" =~ [0-9]+% ]]; then
            echo "$line"
          fi
        done

        # Check if download succeeded
        if [ -f "{{ image_url | basename }}" ]; then
          FILE_SIZE=$(stat -c%s "{{ image_url | basename }}" 2>/dev/null || stat -f%z "{{ image_url | basename }}" 2>/dev/null)
          echo "โ Download completed successfully ($(numfmt --to=iec-i --suffix=B ${FILE_SIZE} 2>/dev/null || echo ${FILE_SIZE} bytes))"
          exit 0
        else
          echo "โ Download failed"
          exit 1
        fi
      args:
        creates: "{{ tmp_base }}/cloudimg-{{ vmid }}/{{ image_url | basename }}"
        executable: /bin/bash
      when: not image_file.stat.exists
      register: download_result
      retries: 3 # Will retry the entire download up to 3 times if it fails
      delay: 30
      until: download_result.rc == 0

    - name: Show download result
      debug:
        msg: "โ Cloud image download complete"
      when:
        - download_result is succeeded
        - not image_file.stat.exists

    - name: Download SHA256SUMS for verification
      get_url:
        url: "{{ image_url | regex_replace('/[^/]+$', '/SHA256SUMS') }}"
        dest: "{{ tmp_base }}/cloudimg-{{ vmid }}/SHA256SUMS"
        timeout: 30
      ignore_errors: true
      register: checksum_download

    - name: Verify cloud image checksum
      debug:
        msg: "๐ Verifying image integrity with SHA256 checksum..."
      when: checksum_download is succeeded

    - name: Calculate and compare checksums
      shell: |
        cd {{ tmp_base }}/cloudimg-{{ vmid }}
        echo "๐ Comparing checksums..."

        # Try to find checksum for this specific file
        EXPECTED=$(grep "{{ image_url | basename }}" SHA256SUMS | awk '{print $1}' || echo "")

        if [ -z "${EXPECTED}" ]; then
          echo "โ๏ธ  No checksum found in SHA256SUMS for {{ image_url | basename }}"
          echo "   This can happen when using /current/ symlink URLs"
          echo "   Skipping checksum verification (file size check will still validate)"
          exit 0
        fi

        echo "   Expected: ${EXPECTED}"
        echo "   Calculating actual checksum (this may take 30-60 seconds)..."
        ACTUAL=$(sha256sum "{{ image_url | basename }}" | awk '{print $1}')
        echo "   Actual:   ${ACTUAL}"

        if [ "${ACTUAL}" != "${EXPECTED}" ]; then
          echo "โ CHECKSUM_MISMATCH: Image is corrupted or partially downloaded!"
          echo "   Removing corrupted file to allow retry..."
          rm -f "{{ image_url | basename }}"
          exit 1
        fi

        echo "โ Checksum verified successfully - image is valid"
      when: checksum_download is succeeded
      register: checksum_verify
      ignore_errors: true

    - name: Show checksum verification result
      debug:
        msg: "{{ checksum_verify.stdout_lines | default(['โ๏ธ  Checksum verification skipped']) }}"
      when: checksum_download is succeeded

    - name: Warn if checksum verification was skipped or failed
      debug:
        msg: |
          โ๏ธ  WARNING: Checksum verification was not completed
          Proceeding with file size validation only.
          The image will still be validated for minimum size (200MB).
      when: checksum_download is failed or (checksum_verify is defined and checksum_verify is failed)

    - name: Validate image file size (should be > 200MB)
      stat:
        path: "{{ tmp_base }}/cloudimg-{{ vmid }}/{{ image_url | basename }}"
      register: image_size

    - name: Check if image file is large enough
      fail:
        msg: "โ Downloaded image is too small ({{ (image_size.stat.size / 1024 / 1024) | int }}MB). Expected > 200MB. Download may be corrupted."
      when: image_size.stat.size < 209715200

    - name: Creating Proxmox VM
      debug:
        msg: "๐ง Step 1/4: Creating temporary VM {{ vmid }} on Proxmox..."

    - name: Create temporary VM
      shell: |
        #!/bin/bash
        set -e
        echo "Creating VM {{ vmid }}..."
        qm create {{ vmid }} --name temp-import-{{ vmid }} --memory {{ memory }} --cores {{ cores }}
        echo "โ VM created successfully"
      args:
        executable: /bin/bash
      register: vm_create_result

    - name: Display VM creation result
      debug:
        msg: "{{ vm_create_result.stdout_lines }}"

    - name: Importing disk to storage
      debug:
        msg: "๐พ Step 2/4: Importing cloud image to storage '{{ storage }}' (this may take 1-2 minutes)..."

    - name: Import disk into storage
      shell: |
        #!/bin/bash
        set -e
        cd {{ tmp_base }}/cloudimg-{{ vmid }}
        echo "   Importing {{ image_url | basename }} to storage {{ storage }}..."
        echo "   This may take 1-2 minutes depending on storage speed..."

        # Import the disk and capture output
        if qm importdisk {{ vmid }} "{{ image_url | basename }}" {{ storage }} 2>&1 | tee /tmp/import_{{ vmid }}.log; then
          echo "   โ Disk imported successfully"
          
          # Verify the disk was created
          if pvesm list {{ storage }} | grep -q "vm-{{ vmid }}-disk-0"; then
            echo "   โ Verified: Disk vm-{{ vmid }}-disk-0 exists in storage"
          else
            echo "   โ ERROR: Disk was not created in storage!"
            echo "   Available disks for VM {{ vmid }}:"
            pvesm list {{ storage }} | grep "vm-{{ vmid }}" || echo "   No disks found!"
            exit 1
          fi
        else
          echo "   โ ERROR: qm importdisk failed!"
          cat /tmp/import_{{ vmid }}.log
          exit 1
        fi
      args:
        executable: /bin/bash
      register: import_result

    - name: Display import result
      debug:
        msg: "{{ import_result.stdout_lines }}"

    - name: Configuring VM
      debug:
        msg: "โ๏ธ  Step 3/4: Configuring VM boot settings and cloud-init..."

    - name: Attach imported disk as scsi0 and configure VM
      shell: |
        #!/bin/bash
        set -e
        echo "Attaching disk to VM {{ vmid }}..."

        # Attach the disk
        if qm set {{ vmid }} --scsi0 {{ storage }}:vm-{{ vmid }}-disk-0; then
          echo "โ Disk attached as scsi0"
        else
          echo "โ Failed to attach disk!"
          exit 1
        fi

        # Add cloud-init drive (CRITICAL for cloud-init to work!)
        if qm set {{ vmid }} --ide2 {{ storage }}:cloudinit; then
          echo "โ Cloud-init drive added (ide2)"
        else
          echo "โ Failed to add cloud-init drive!"
          exit 1
        fi

        # Set boot order
        if qm set {{ vmid }} --boot order=scsi0; then
          echo "โ Boot order set to scsi0"
        else
          echo "โ Failed to set boot order!"
          exit 1
        fi

        # Enable QEMU agent
        if qm set {{ vmid }} --agent 1; then
          echo "โ QEMU agent enabled"
        else
          echo "โ  Warning: Failed to enable QEMU agent (non-critical)"
        fi

        # Set serial console (helpful for debugging)
        if qm set {{ vmid }} --serial0 socket --vga serial0; then
          echo "โ Serial console configured"
        else
          echo "โ  Warning: Failed to set serial console (non-critical)"
        fi

        # Verify the configuration
        echo ""
        echo "Verifying VM configuration..."
        if qm config {{ vmid }} | grep -E "^scsi0:" > /dev/null; then
          SCSI0_LINE=$(qm config {{ vmid }} | grep "^scsi0:")
          echo "โ Boot disk configured: ${SCSI0_LINE}"
        else
          echo "โ CRITICAL ERROR: No boot disk (scsi0) found in VM config!"
          echo "Full VM config:"
          qm config {{ vmid }}
          exit 1
        fi

        if qm config {{ vmid }} | grep -E "^ide2:" > /dev/null; then
          IDE2_LINE=$(qm config {{ vmid }} | grep "^ide2:")
          echo "โ Cloud-init drive configured: ${IDE2_LINE}"
        else
          echo "โ CRITICAL ERROR: No cloud-init drive (ide2) found in VM config!"
          echo "Full VM config:"
          qm config {{ vmid }}
          exit 1
        fi

        if qm config {{ vmid }} | grep -E "^boot:" > /dev/null; then
          BOOT_LINE=$(qm config {{ vmid }} | grep "^boot:")
          echo "โ Boot order configured: ${BOOT_LINE}"
        else
          echo "โ  Warning: No boot order in config (may use defaults)"
        fi
      args:
        executable: /bin/bash
      register: attach_result

    - name: Display attachment result
      debug:
        msg: "{{ attach_result.stdout_lines }}"

    - name: Converting to template
      debug:
        msg: "๐ฆ Step 4/4: Converting VM to template..."

    - name: Convert VM to template
      shell: |
        qm template {{ vmid }}

    - name: Set template name
      shell: |
        qm set {{ vmid }} --name {{ template_name }} || true

    - name: Validating template
      debug:
        msg: "๐ Validating template boot disk and cloud-init configuration..."

    - name: Validate template has boot disk and cloud-init configured
      shell: |
        #!/bin/bash
        ERRORS=0

        # Check for boot disk
        if ! qm config {{ vmid }} | grep -E '^(scsi0|ide0|sata0):' > /dev/null; then
          echo "โ ERROR: No boot disk found!"
          ERRORS=$((ERRORS + 1))
        fi

        # Check for cloud-init drive
        if ! qm config {{ vmid }} | grep -E '^ide2:.*cloudinit' > /dev/null; then
          echo "โ ERROR: No cloud-init drive found!"
          ERRORS=$((ERRORS + 1))
        fi

        if [ $ERRORS -gt 0 ]; then
          echo "Full config:"
          qm config {{ vmid }}
          exit 1
        fi

        # Print successful config
        qm config {{ vmid }} | grep -E '^(scsi0|ide2):'
      args:
        executable: /bin/bash
      register: boot_disk_check
      failed_when: boot_disk_check.rc != 0

    - name: Display template configuration
      debug:
        msg: "โ Template validated - {{ boot_disk_check.stdout_lines | join(', ') }}"

    - name: Cleaning up
      debug:
        msg: "๐งน Cleaning up temporary files..."

    - name: Cleanup temporary files
      file:
        path: "{{ tmp_base }}/cloudimg-{{ vmid }}"
        state: absent

    - name: Show completion message
      debug:
        msg: |

          โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
          โ                                                                โ
          โ  โ  SUCCESS! CLOUD-INIT TEMPLATE CREATED & VALIDATED         โ
          โ                                                                โ
          โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโฃ
          โ  Template Name:  {{ template_name }}
          โ  VMID:           {{ vmid }}
          โ  Proxmox Host:   {{ inventory_hostname }}
          โ  Boot Disk:      {{ boot_disk_check.stdout }}
          โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ

          ๐ Template is ready for VM deployment!
